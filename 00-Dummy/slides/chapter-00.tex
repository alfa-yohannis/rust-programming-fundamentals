\documentclass[aspectratio=169, table]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{listings}

\usetheme{Pradita}

\subtitle{IF120203-Programming Fundamentals}

\title{Session-17:\\\LARGE{Iterators: Set Operations}\\ \vspace{10pt}}
\date[Serial]{\scriptsize {PRU/SPMI/FR-BM-18/0222}}
\author[Pradita]{\small{\textbf{Alfa Yohannis}}}

\lstdefinelanguage{Rust} {
	keywords={MAX, std, print, fn, let, mut, println, true, false, u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, f32, f64, char, bool, if, else, for, while, loop, match, return},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={self, String, HashMap, Entry, or_insert},
	ndkeywordstyle=\color{purple}\bfseries,
	sensitive=true,
	commentstyle=\color{gray},
	stringstyle=\color{red},
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{lightgray!10},
	tabsize=2,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{gray}\ttfamily,
	stringstyle=\color{purple}\ttfamily,
	showstringspaces=false
}

\begin{document}
	
	\frame{\titlepage}
	
	\begin{frame}[fragile]
		\frametitle{Set Operations: Union and Intersection with Different Values}
		\begin{lstlisting}[language=Rust]
			fn main() {
				let mut set1: Vec<u32> = vec![2, 7, 8, 11, 14];
				let mut set2: Vec<u32> = vec![2, 6, 8, 10, 13, 18, 22];
				
				let common_elements = find_intersection(&set1, &set2);
				println!("\n\n The intersection of the two sets is {:?}", common_elements);
				
				let union_set = compute_union(&mut set1, &mut set2, &common_elements);
				println!("\n\n The union of the sets is {:?}", union_set);
				
				// Alternative method for intersection
				let set1_copy = set1.clone();
				
				// Alternative way to find common elements
				let common_elements: Vec<u32> = set1.into_iter()
				.filter(|&x| set2.iter().any(|&y| y == x))
				.collect();
				println!("The common values are {:?}", common_elements);
				// This approach will consume set1
				
				println!("The uncommon values are {:?}", uncommon_elements);
			}
			
			// Function to find the intersection of two sets
			fn find_intersection(set1: &Vec<u32>, set2: &Vec<u32>) -> Vec<u32> {
				let mut common_elements: Vec<u32> = Vec::new();
				
				for item in set1 {
					if set2.iter().any(|&x| x == *item) {
						common_elements.push(*item);
					}
				}
				common_elements
			}
			
			// Function to compute the union of two sets, excluding common elements
			fn compute_union<'a>(set1: &'a mut Vec<u32>, set2: &'a mut Vec<u32>, common_elements: &'a Vec<u32>) -> Vec<&'a u32> {
				for item in common_elements {
					if let Some(pos1) = set1.iter().position(|&x| x == *item) {
						set1.remove(pos1);
					}
					if let Some(pos2) = set2.iter().position(|&x| x == *item) {
						set2.remove(pos2);
					}
				}
				let union_set = set1.iter()
				.chain(set2.iter())
				.chain(common_elements.iter())
				.collect::<Vec<_>>();
				union_set
			}
		\end{lstlisting}
		\begin{itemize}
			\item Initializes two vectors with different values.
			\item Computes the intersection of the two vectors.
			\item Calculates the union of the vectors while excluding the intersection.
			\item Includes an alternative method for finding common elements.
		\end{itemize}
	\end{frame}
	
\end{document}
