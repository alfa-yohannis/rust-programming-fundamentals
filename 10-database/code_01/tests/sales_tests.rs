use chrono::Utc;
use database::sales_order::{
    add_sales_order, delete_sales_order, get_sales_order, update_sales_order, SalesOrder,
};
use database::sales_order_detail::{
    add_sales_order_detail, delete_sales_order_detail, delete_sales_order_detail_by_code, get_details_by_order_code, get_sales_order_detail, update_sales_order_detail, SalesOrderDetail
};
use tokio_postgres::NoTls;

#[tokio::test]
async fn test_sales_order_with_details() -> Result<(), Box<dyn std::error::Error>> {
    let (client, connection) = tokio_postgres::connect(
        "host=localhost user=postgres password=1234 dbname=session10",
        NoTls,
    )
    .await?;
    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("connection error: {}", e);
        }
    });

    // Step 1: Create Sales Order (Header)
    let new_order = SalesOrder {
        code: "SO12345678".to_string(),
        order_date: Utc::now(),
        note: None,
    };

    let details = vec![
        SalesOrderDetail {
            id: 0, // This will be auto-generated by the database
            order_code: new_order.code.clone(),
            line_num: 1,
            item_id: 100,
            quantity: 2.0,
            unit: Some("pcs".to_string()),
            unit_price: 50.0,
        },
        SalesOrderDetail {
            id: 0, // This will be auto-generated by the database
            order_code: new_order.code.clone(),
            line_num: 2,
            item_id: 101,
            quantity: 5.0,
            unit: Some("pcs".to_string()),
            unit_price: 75.0,
        },
    ];

    // Step 2.1 Delete
    // delete the sales order to prevent conflict when adding
    for detail in &details {
        delete_sales_order_detail_by_code(&client, &detail.order_code).await?;
    }
    delete_sales_order(&client, &new_order.code).await?;

    // Step 2.2 Adding
    // Add the sales order (header)
    add_sales_order(&client, &new_order).await?;

    // Add the sales order details
    for detail in &details {
        add_sales_order_detail(&client, detail).await?;
    }

    // Step 3: Retrieve and Verify Sales Order and its Details
    let fetched_order = get_sales_order(&client, &new_order.code).await?;
    assert!(fetched_order.is_some());
    assert_eq!(fetched_order.unwrap().code, new_order.code);

    let fetched_details = get_details_by_order_code(&client, &new_order.code).await?;
    assert_eq!(fetched_details.len(), details.len());

    for (i, detail) in details.iter().enumerate() {
        assert_eq!(fetched_details[i].order_code, detail.order_code);
        assert_eq!(fetched_details[i].line_num, detail.line_num);
        assert_eq!(fetched_details[i].item_id, detail.item_id);
        assert_eq!(fetched_details[i].quantity, detail.quantity);
        assert_eq!(fetched_details[i].unit, detail.unit);
        assert_eq!(fetched_details[i].unit_price, detail.unit_price);
    }

    // Step 4: Update Sales Order and Details
    let mut updated_order = new_order.clone();
    updated_order.order_date = Utc::now();
    update_sales_order(&client, &updated_order).await?;

    let mut updated_details = details.clone();
    updated_details[0].quantity = 3.0; // Update quantity for the first detail
    for detail in &updated_details {
        update_sales_order_detail(&client, detail).await?;
    }

    // Verify updates
    let updated_fetched_details = get_details_by_order_code(&client, &new_order.code).await?;
    assert_eq!(
        updated_fetched_details[0].quantity,
        updated_details[0].quantity
    );

    // Step 5: Clean up by Deleting Sales Order and its Details
    for detail in &updated_details {
        delete_sales_order_detail(&client, detail).await?;
    }
    delete_sales_order(&client, &new_order.code).await?;

    // Verify deletions
    let deleted_details = get_details_by_order_code(&client, &new_order.code).await?;
    assert!(deleted_details.is_empty());

    let deleted_order = get_sales_order(&client, &new_order.code).await?;
    assert!(deleted_order.is_none());

    Ok(())
}
